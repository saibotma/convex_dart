// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'convex_client.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$ConvexValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConvexValueCopyWith<$Res> {
  factory $ConvexValueCopyWith(
    ConvexValue value,
    $Res Function(ConvexValue) then,
  ) = _$ConvexValueCopyWithImpl<$Res, ConvexValue>;
}

/// @nodoc
class _$ConvexValueCopyWithImpl<$Res, $Val extends ConvexValue>
    implements $ConvexValueCopyWith<$Res> {
  _$ConvexValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ConvexValue_NullImplCopyWith<$Res> {
  factory _$$ConvexValue_NullImplCopyWith(
    _$ConvexValue_NullImpl value,
    $Res Function(_$ConvexValue_NullImpl) then,
  ) = __$$ConvexValue_NullImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ConvexValue_NullImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_NullImpl>
    implements _$$ConvexValue_NullImplCopyWith<$Res> {
  __$$ConvexValue_NullImplCopyWithImpl(
    _$ConvexValue_NullImpl _value,
    $Res Function(_$ConvexValue_NullImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ConvexValue_NullImpl extends ConvexValue_Null {
  const _$ConvexValue_NullImpl() : super._();

  @override
  String toString() {
    return 'ConvexValue.null_()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ConvexValue_NullImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return null_();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return null_?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return null_(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return null_?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (null_ != null) {
      return null_(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Null extends ConvexValue {
  const factory ConvexValue_Null() = _$ConvexValue_NullImpl;
  const ConvexValue_Null._() : super._();
}

/// @nodoc
abstract class _$$ConvexValue_StringImplCopyWith<$Res> {
  factory _$$ConvexValue_StringImplCopyWith(
    _$ConvexValue_StringImpl value,
    $Res Function(_$ConvexValue_StringImpl) then,
  ) = __$$ConvexValue_StringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$ConvexValue_StringImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_StringImpl>
    implements _$$ConvexValue_StringImplCopyWith<$Res> {
  __$$ConvexValue_StringImplCopyWithImpl(
    _$ConvexValue_StringImpl _value,
    $Res Function(_$ConvexValue_StringImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_StringImpl(
        null == field0
            ? _value.field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_StringImpl extends ConvexValue_String {
  const _$ConvexValue_StringImpl(this.field0) : super._();

  @override
  final String field0;

  @override
  String toString() {
    return 'ConvexValue.string(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_StringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_StringImplCopyWith<_$ConvexValue_StringImpl> get copyWith =>
      __$$ConvexValue_StringImplCopyWithImpl<_$ConvexValue_StringImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return string(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return string?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return string(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return string?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (string != null) {
      return string(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_String extends ConvexValue {
  const factory ConvexValue_String(final String field0) =
      _$ConvexValue_StringImpl;
  const ConvexValue_String._() : super._();

  String get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_StringImplCopyWith<_$ConvexValue_StringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConvexValue_Int64ImplCopyWith<$Res> {
  factory _$$ConvexValue_Int64ImplCopyWith(
    _$ConvexValue_Int64Impl value,
    $Res Function(_$ConvexValue_Int64Impl) then,
  ) = __$$ConvexValue_Int64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$ConvexValue_Int64ImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_Int64Impl>
    implements _$$ConvexValue_Int64ImplCopyWith<$Res> {
  __$$ConvexValue_Int64ImplCopyWithImpl(
    _$ConvexValue_Int64Impl _value,
    $Res Function(_$ConvexValue_Int64Impl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_Int64Impl(
        null == field0
            ? _value.field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as int,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_Int64Impl extends ConvexValue_Int64 {
  const _$ConvexValue_Int64Impl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'ConvexValue.int64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_Int64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_Int64ImplCopyWith<_$ConvexValue_Int64Impl> get copyWith =>
      __$$ConvexValue_Int64ImplCopyWithImpl<_$ConvexValue_Int64Impl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return int64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return int64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return int64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return int64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (int64 != null) {
      return int64(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Int64 extends ConvexValue {
  const factory ConvexValue_Int64(final int field0) = _$ConvexValue_Int64Impl;
  const ConvexValue_Int64._() : super._();

  int get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_Int64ImplCopyWith<_$ConvexValue_Int64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConvexValue_Float64ImplCopyWith<$Res> {
  factory _$$ConvexValue_Float64ImplCopyWith(
    _$ConvexValue_Float64Impl value,
    $Res Function(_$ConvexValue_Float64Impl) then,
  ) = __$$ConvexValue_Float64ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double field0});
}

/// @nodoc
class __$$ConvexValue_Float64ImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_Float64Impl>
    implements _$$ConvexValue_Float64ImplCopyWith<$Res> {
  __$$ConvexValue_Float64ImplCopyWithImpl(
    _$ConvexValue_Float64Impl _value,
    $Res Function(_$ConvexValue_Float64Impl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_Float64Impl(
        null == field0
            ? _value.field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as double,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_Float64Impl extends ConvexValue_Float64 {
  const _$ConvexValue_Float64Impl(this.field0) : super._();

  @override
  final double field0;

  @override
  String toString() {
    return 'ConvexValue.float64(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_Float64Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_Float64ImplCopyWith<_$ConvexValue_Float64Impl> get copyWith =>
      __$$ConvexValue_Float64ImplCopyWithImpl<_$ConvexValue_Float64Impl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return float64(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return float64?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return float64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return float64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (float64 != null) {
      return float64(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Float64 extends ConvexValue {
  const factory ConvexValue_Float64(final double field0) =
      _$ConvexValue_Float64Impl;
  const ConvexValue_Float64._() : super._();

  double get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_Float64ImplCopyWith<_$ConvexValue_Float64Impl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConvexValue_ArrayImplCopyWith<$Res> {
  factory _$$ConvexValue_ArrayImplCopyWith(
    _$ConvexValue_ArrayImpl value,
    $Res Function(_$ConvexValue_ArrayImpl) then,
  ) = __$$ConvexValue_ArrayImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ConvexValue> field0});
}

/// @nodoc
class __$$ConvexValue_ArrayImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_ArrayImpl>
    implements _$$ConvexValue_ArrayImplCopyWith<$Res> {
  __$$ConvexValue_ArrayImplCopyWithImpl(
    _$ConvexValue_ArrayImpl _value,
    $Res Function(_$ConvexValue_ArrayImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_ArrayImpl(
        null == field0
            ? _value._field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as List<ConvexValue>,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_ArrayImpl extends ConvexValue_Array {
  const _$ConvexValue_ArrayImpl(final List<ConvexValue> field0)
    : _field0 = field0,
      super._();

  final List<ConvexValue> _field0;
  @override
  List<ConvexValue> get field0 {
    if (_field0 is EqualUnmodifiableListView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_field0);
  }

  @override
  String toString() {
    return 'ConvexValue.array(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_ArrayImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_ArrayImplCopyWith<_$ConvexValue_ArrayImpl> get copyWith =>
      __$$ConvexValue_ArrayImplCopyWithImpl<_$ConvexValue_ArrayImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return array(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return array?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return array(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return array?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (array != null) {
      return array(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Array extends ConvexValue {
  const factory ConvexValue_Array(final List<ConvexValue> field0) =
      _$ConvexValue_ArrayImpl;
  const ConvexValue_Array._() : super._();

  List<ConvexValue> get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_ArrayImplCopyWith<_$ConvexValue_ArrayImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConvexValue_ObjectImplCopyWith<$Res> {
  factory _$$ConvexValue_ObjectImplCopyWith(
    _$ConvexValue_ObjectImpl value,
    $Res Function(_$ConvexValue_ObjectImpl) then,
  ) = __$$ConvexValue_ObjectImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Map<String, ConvexValue> field0});
}

/// @nodoc
class __$$ConvexValue_ObjectImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_ObjectImpl>
    implements _$$ConvexValue_ObjectImplCopyWith<$Res> {
  __$$ConvexValue_ObjectImplCopyWithImpl(
    _$ConvexValue_ObjectImpl _value,
    $Res Function(_$ConvexValue_ObjectImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_ObjectImpl(
        null == field0
            ? _value._field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as Map<String, ConvexValue>,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_ObjectImpl extends ConvexValue_Object {
  const _$ConvexValue_ObjectImpl(final Map<String, ConvexValue> field0)
    : _field0 = field0,
      super._();

  final Map<String, ConvexValue> _field0;
  @override
  Map<String, ConvexValue> get field0 {
    if (_field0 is EqualUnmodifiableMapView) return _field0;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_field0);
  }

  @override
  String toString() {
    return 'ConvexValue.object(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_ObjectImpl &&
            const DeepCollectionEquality().equals(other._field0, _field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_field0));

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_ObjectImplCopyWith<_$ConvexValue_ObjectImpl> get copyWith =>
      __$$ConvexValue_ObjectImplCopyWithImpl<_$ConvexValue_ObjectImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return object(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return object?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return object(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return object?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (object != null) {
      return object(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Object extends ConvexValue {
  const factory ConvexValue_Object(final Map<String, ConvexValue> field0) =
      _$ConvexValue_ObjectImpl;
  const ConvexValue_Object._() : super._();

  Map<String, ConvexValue> get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_ObjectImplCopyWith<_$ConvexValue_ObjectImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ConvexValue_BytesImplCopyWith<$Res> {
  factory _$$ConvexValue_BytesImplCopyWith(
    _$ConvexValue_BytesImpl value,
    $Res Function(_$ConvexValue_BytesImpl) then,
  ) = __$$ConvexValue_BytesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Uint8List field0});
}

/// @nodoc
class __$$ConvexValue_BytesImplCopyWithImpl<$Res>
    extends _$ConvexValueCopyWithImpl<$Res, _$ConvexValue_BytesImpl>
    implements _$$ConvexValue_BytesImplCopyWith<$Res> {
  __$$ConvexValue_BytesImplCopyWithImpl(
    _$ConvexValue_BytesImpl _value,
    $Res Function(_$ConvexValue_BytesImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? field0 = null}) {
    return _then(
      _$ConvexValue_BytesImpl(
        null == field0
            ? _value.field0
            : field0 // ignore: cast_nullable_to_non_nullable
                  as Uint8List,
      ),
    );
  }
}

/// @nodoc

class _$ConvexValue_BytesImpl extends ConvexValue_Bytes {
  const _$ConvexValue_BytesImpl(this.field0) : super._();

  @override
  final Uint8List field0;

  @override
  String toString() {
    return 'ConvexValue.bytes(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ConvexValue_BytesImpl &&
            const DeepCollectionEquality().equals(other.field0, field0));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(field0));

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ConvexValue_BytesImplCopyWith<_$ConvexValue_BytesImpl> get copyWith =>
      __$$ConvexValue_BytesImplCopyWithImpl<_$ConvexValue_BytesImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() null_,
    required TResult Function(String field0) string,
    required TResult Function(int field0) int64,
    required TResult Function(double field0) float64,
    required TResult Function(List<ConvexValue> field0) array,
    required TResult Function(Map<String, ConvexValue> field0) object,
    required TResult Function(Uint8List field0) bytes,
  }) {
    return bytes(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? null_,
    TResult? Function(String field0)? string,
    TResult? Function(int field0)? int64,
    TResult? Function(double field0)? float64,
    TResult? Function(List<ConvexValue> field0)? array,
    TResult? Function(Map<String, ConvexValue> field0)? object,
    TResult? Function(Uint8List field0)? bytes,
  }) {
    return bytes?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? null_,
    TResult Function(String field0)? string,
    TResult Function(int field0)? int64,
    TResult Function(double field0)? float64,
    TResult Function(List<ConvexValue> field0)? array,
    TResult Function(Map<String, ConvexValue> field0)? object,
    TResult Function(Uint8List field0)? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvexValue_Null value) null_,
    required TResult Function(ConvexValue_String value) string,
    required TResult Function(ConvexValue_Int64 value) int64,
    required TResult Function(ConvexValue_Float64 value) float64,
    required TResult Function(ConvexValue_Array value) array,
    required TResult Function(ConvexValue_Object value) object,
    required TResult Function(ConvexValue_Bytes value) bytes,
  }) {
    return bytes(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ConvexValue_Null value)? null_,
    TResult? Function(ConvexValue_String value)? string,
    TResult? Function(ConvexValue_Int64 value)? int64,
    TResult? Function(ConvexValue_Float64 value)? float64,
    TResult? Function(ConvexValue_Array value)? array,
    TResult? Function(ConvexValue_Object value)? object,
    TResult? Function(ConvexValue_Bytes value)? bytes,
  }) {
    return bytes?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvexValue_Null value)? null_,
    TResult Function(ConvexValue_String value)? string,
    TResult Function(ConvexValue_Int64 value)? int64,
    TResult Function(ConvexValue_Float64 value)? float64,
    TResult Function(ConvexValue_Array value)? array,
    TResult Function(ConvexValue_Object value)? object,
    TResult Function(ConvexValue_Bytes value)? bytes,
    required TResult orElse(),
  }) {
    if (bytes != null) {
      return bytes(this);
    }
    return orElse();
  }
}

abstract class ConvexValue_Bytes extends ConvexValue {
  const factory ConvexValue_Bytes(final Uint8List field0) =
      _$ConvexValue_BytesImpl;
  const ConvexValue_Bytes._() : super._();

  Uint8List get field0;

  /// Create a copy of ConvexValue
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ConvexValue_BytesImplCopyWith<_$ConvexValue_BytesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
